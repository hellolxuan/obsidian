---
title: Java
tags: 
    - Java
author: Lxuan
date: 2022-07-16 02:07:13
thumbnail: /2022/07/16/Java/Java.png
cover: /2022/07/16/Java/Java.png
top_img: /2022/07/16/Java/Java.png
toc: true
keywords: Java
categories: 学习与技术总结
top: 
rating: 
---


## 1. 类与对象

![对象在内存中的存在形式](Java/对象在内存中的存在形式.jpg)



### 1.1 作用域

| 作用域    | 当前类 | 同一包 | 子类 | 不同包 |
| --------- | ------ | ------ | ---- | ------ |
| public    | √      | √      | √    | √      |
| protected | √      | √      | √    | x      |
| private   | √      | x      | x    | x      |
|           |        |        |      |        |

全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。

1. 属性和局部变量可以重名，访问时遵循就近原则。
2. 同一个作用域中，两个局部变量不能重名。
3. 全局变量可以加修饰符，局部变量不行。

### 1.2 构造器

  构造方法又叫构造器（constructor），是类的一种特殊方法，它的主要作用是完成对<u>*新对象的初始化*</u>。

1. 构造器修饰符可以默认，也可以是public protected private

2. <u>构造器没有返回值</u>

3. <u>方法名和类名必须一样</u>

4. 参数列表和成员方法一样的规则

5. 构造器的调用，由系统完成

6. <u>构造器可以重载</u>

   new 一个新对象的时候，会自动执行构造器，因此new时可以直接赋值，如：

   Person p1 = new Person ("梁渲"， 20);

### 1.3 this关键字

this(参数列表)只能在构造器中使用，也就是在一个构造器中访问另一个构造器，必须放在第一条语句，即同一给构造器中只能出现一次

### 1.4 对象可以为空，也就是说返回值可以为null

### 1.5 数组可以为空

### 1.6 方法中的变量称为局部变量，之外的变量称为全局变量，this.是全局变量

### 1.7 一个Java源文件中可以有多个主类，但是只能有一个公共类或者没有公共类

java源文件在运行后会被编译成一个个class文件，但public类只能有一个，而主类main()方法可以有多个，main()方法是程序执行的入口

## 2. 包

作用：

1. 区分相同名字的类
2. 当类很多时，可以很好的管理类[看Java API 文档]
3. 控制访问范围

---



## 3. 继承

1. 如果子类有这个属性，则输出，如果子类没有这个属性，则依次往上找父类的属性。

2. 私有属性不能直接在子类中访问，需要用父类提供的公共方法去访问，如下。

   ```java
   class A {
     private name = "张三";
     
     public String getName () {
       return name;
     }
   }
   class B extends A {
     
   }
   main{
     B b1 = new B;
     System.out.print(b1.name); // 报错
     System.out.print(b1.getName); // 返回张三
   }
   ```

3. 子类的任何方法的第一行都存在一个 super() 方法，该方法用于执行父类的无参构造器；但 this(); 和 super() 不能共存，若是子类的构造器中存在 this(); 方法，则super(); 也就不会存在了。

---

## 4. 多态

1. 一个对象的编译类型和运行类型可以不一致
2. 编译类型在定义对象时，就确定了，不能改变
3. 运行类型是可以变化的
4. 编译类型是看定义时 = 的左边，运行类型看 = 右边

### 4.1 Java的动态绑定机制

1. 当调用对象方法的时候，该方法会和该对象的**内存地址/运行类型**绑定
2. 当调用对象的属性时，没有动态绑定机制，哪里声明就在哪里使用

---

## 5. Object类详解

### 5.1 equals方法

==是一个比较运算符

> 1. 既可以判断基本类型，又可以判断引用类型
> 2. 如果判断基本类型，判断的是值是否相等。
> 3. 如果判断引用类型，判断的是地址是否相同，即判断是否是同一个对象。

equal：是Object类中的方法，只能判断引用类型，默认判断的是地址是否先等，子类中往往重写该方法，用于判断内容是否相等

| 名称  | 概念                             | 用于基本数据类型     | 用于引用类型                                                 |
| ----- | -------------------------------- | :------------------- | ------------------------------------------------------------ |
| ==    | 比较运算符                       | 可以，判断值是否相等 | 可以，判断两个对象是否相等                                   |
| equal         | object类的方法，Java类都可以使用 | 不可以               | 可以，默认是判断两个对象是否相等，但是子类往往重写该方法，比较对象的属性是否相等，比如（String,Integer) |

## 6. javap 反编译

![javap](../绘图/javap.md)

# 面向对象编程（高级）

## 1. 类变量和类方法

### 1.1 类变量

类变量也叫静态变量，被 static 修饰的变量会被所有对象实例共享。

```java
public static int count = 0;
```

在jdk8以前，静态变量是放在方法区里的静态域，jdk8以后静态变量是放在堆里的，保存在class实例的尾部。

---

1. static被所有对象共享，任何一个对象访问的都是同一个值，修改的也是同一个变量。

2. static类变量，在类加载的时候就生成了，所以即使没有对象实例也可以访问，如：

   ```java
   System.out.println(类名.静态变量);
   ```

   

### 1.2 类方法

类方法与类变量同理

我们在调用 Java 中的 Math 工具时，从来都不需要创建一个 Math 对象，就是因为 Math 类中的方法都是静态方法。

因此我们可以将静态方法作为一种工具方法，放在工具类中随时调用。

---

1. 类方法中不允许使用和对象有关的关键字，比如 this 和 super ，普通方法可以。
2. 类方法中**只能**访问类变量和类方法，普通方法都可以访问。

### 1.3 理解 main 方法语法

解释 main 方法的形式：

```java
public static vod main(String[] ages){}
```

1. main 方法是虚拟机调用

2. Java虚拟机西药调用类的 main() 方法，所以该方法的访问权限必须是public

3. java虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static 

4. 该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数

5. java 源文件执行的方式：java 类名.java 参数1 参数2 参数3

   ```java
   java hello.java qwe asd zxc
   ```



## 2. 代码块

1. 代码块主要解决构造器中重复出现的语句。
2. 代码块调用的顺序优先于构造器。
3. 静态代码块只能调用静态属性和静态方法
4. 普通代码块都能调用

static 代码块也叫静态代码块，作用就是对类进行初始化，伴随着类的加载而执行，且**只会执行一次**

类什么时候被加载？

* 创建对象实例（new）的时候
* 创建子类对象实例，父类也会被加载
* 实用类的静态成员时（类方法，类属性）

普通代码块每创建一次就执行一次



## 3. 单例设计模式

一个类只能同时存在一个实例（对象）

1. 饿汉式
   1. 构造器私有化
   2. 类的内部创建实例（对象）
   3. 创建一个公共的 static 方法，返回该实例（对象）
2. 懒汉式
   1. （与上相同）
   2. 与饿汉式不同的是，懒汉式在用户不调用的时候不会加载对象



## 4. final 关键字

1. 定义：

   final 修饰的属性又叫常量，一般用大写来命名

2. 使用 final 的注意事项
   1. final 修饰类的时候，类不能被继承
   2. final 修饰方法的时候，父类的方法不能被子类重写/覆盖（override）
   3. final 修饰属性值的时候，属性值不能被修改
   4. final 修饰的属性在定义时必须赋值，之后就不能再修改（赋值位置：定义时、代码块中、构造器中）。如果 final 修饰的属性是静态的，则初始化位置只能是在定义时，代码块中（不能在构造器中）
   5. 虽然被 final 修饰的方法不能被重写，但是可以被继承和使用
   6. 如果一个类已经被 final 修饰，那类中的方法就不用 final 修饰了
   7. final 不能被修饰构造器
   8. final 和 static 搭配使用效率更高，底层代码做了优化（使用 static 会加载整个类，但是加上 final 就不会加载整个类了）



## 5. 抽象类

1. 抽象类不一定要抽象方法，抽象方法必须为抽象类

2. 抽象类不能被实例化

3.  abstract 只能修饰类和方法，不能修饰属性和其他

4. 如果一个类继承了抽=抽象类，则它必须实现抽象类中的所有方法，除非它自己也声明为抽象类

5. 抽象方法不能使用 private、static 和  final 来修饰，因为这些修饰词都和重写相违背

   > static：
   >
   > 被 static修饰的方法在和没有 static 修饰的方法在内存中的位置不一样。。
   > 被static修饰的方法属于类，是类自己的东西，不是给子类来继承的。就好像类是个房子，它的静态方法是里面的一面墙，每个人都可已在墙上画画，你画的东西别人也能看到，属于大家共同使用。你想通过继承来把这面墙拿走也不可能拿走，他是从属于类的。
   > 而抽象方法本身没有实现，就是用来给子类继承，存在内存中的位置也不是一样的。用 static修饰就不能被子类继承了。同样 你可以这么理解。
   > 抽象方法相当于房子中地上的白纸，继承了它的子类就必须从地上拿一张白纸回去画画，你想怎么画怎么画。
   > 一个相当于墙，你是拿不走的。一个相当于地上的纸，而且规定你实现了就必须拿走。
   >
   > final：
   >
   > final修饰的类不可继承，而抽象类本事是不能被实例化的，是需要让子类去继承，如果父类使用了 final 修饰符修饰方法，子类继承后，也无法重写该方法。
   >
   > private：
   >
   > private的访问权限是本类中，子类继承父类后，是无法方法 private 修饰的方法的。

访问修饰符 abstract 类名{}



## 6. 模板设计模式

1. 共同代码模板，不同代码抽象



## 7. 接口

1. jdk8之前，在接口中，抽象方法可以省略 abstract 关键字，也就是说所有方法都是抽象方法，都不能有方法体

2. jdk8后，接口中可以有默认方法，但是需要用 default 关键字修饰

   ```java
   public default void AA(){}
   ```

3. 也可以有静态方法

   ```java
   public static void BB(){}
   ```

4. 一个类可以实现多个接口

   ```java
   class AA implements BB,CC,DD{}
   ```

5. 接口中的属性只能是 final 的，而且是 public static final 修饰符

6. 接口不能继承其它类，但是可以继承其它接口

7. 接口的修饰符只能是 public 或者默认的，这点和类的修饰符是一样的

### 7.1 接口和继承

1. 接口和继承解决的问题不同

   接口的价值主要在于：设计、规定好各种方法，让其它类能够实现这些方法（功能）

   继承的价值主要在于：解决代码的**复用性**和**可维护性**

2. 接口比继承更加灵活

   继承是满足 is - a 的关系

   接口只需满足 like - a 的关系

3. 接口在一定程度上实现代码解耦



## 8. 四种内部类

 类的五大成员：属性、方法、构造器、代码块、内部类

内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

***定义在外部类局部位置上（比如方法内）:***

### 8.1 局部内部类（有类名）

1. 定义在方法中 / 代码块中
2. 可以直接访问定义在外部类的所有成员（属性和方法），包含私有的
3. 不能添加访问修饰符，但是可以私用 final 修饰，被 final 修饰后就可以不被继承
4. 作用域：仅仅在定义它的方法或代码块中
5. 如果外部类和局部内部类的成员重名时，遵守就近原则。在此基础上访问外部成员可以使用 **`外部类名.this.成员`** 去访问，因为 **`外部类名.this`** 的意思就是访问创建了局部内部类这个方法的对象。

### 8.2 匿名内部类（没有类名）<font color = "red">重点！！</font>

1. 定义在方法中 / 代码块中，并且没有类名

2. 使用如下：

   ```java
   AA aa = new AA("name"){
     @Override
     public void A(){
     	....
     }
   };
   aa.A();
   
   或者
   
   new AA(){
     @Override
     public void B(){
     	...
     }
   }.B();
   ```

   匿名内部类没有类名，("name")这个形参列表是传给类的构造器的，当然也可以重写构造器。

3. 可以访问外部类的所有成员，包含私有

4. 不能添加访问修饰符，因为他的地位就是一个局部变量

5. 作用域：定义它的方法或者代码块中

***定义在外部类的成员位置上：***

### 8.3 成员内部类（没用 static 修饰）

1. 直接定义在外部类的成员位置，而不在方法或代码块中，并且没有 static 修饰
2. 可以直接访问外部类的所有成员，包括私有
3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员
4. 使用如下：

    ```java
    第一种方式
    main{
      Outside outside = new Outside();
      Outdise.memberInsideClass memberinsideclass = outside.new memberInsideClass();
    }
    
    第二种方式
    main{
      Outside.MemberInsideClass menberInsideClass = new Outside().getMenberInsideClass();
      memberInsideClass.方法();
    }
    Outside{
      public MemberInsideClass getMenberInsideClass() {
        return new MemberInsideClass();
      }
    }  
    ```

### 8.4 静态内部类（使用 static 修饰）

1. 成员内部类添加 static 修饰符
2. 可以访问外部类所有静态成员，但不能访问非静态
3. 可以添加任意访问修饰符（public、protected、默认、private），因为它本身就是一个成员

# 枚举和注解

## 1. 枚举类

### 1.1 自定义枚举类

1. 构造器私有化：防止被直接 new
2. 去掉 set 方法：防止属性被修改
3. 在外部类直接创建固定的对象（public static final 类名 对象名 = new 类名();）

### 1.2 enum 修饰的枚举类

1. 使用 enum 关键字 替代 class
2. 将 `public static final 类名 对象名 = new 类名();` 简化成 `对象名();` 形式
3. 如果有多个对象使用，使用 `,` 间隔，如： `SPRING("春天","温暖"),WINTER("冬天","寒冷");`
4. 将这些常量对象部分写在类的最前面
