---
title: 设计模式
tags: 
    - 设计模式
    - 课程
author: Lxuan
date: 2022-06-27
thumbnail: 
cover: 
top_img: 
toc: true
keywords: 设计模式
categories: 技术
top: 
---


# <center>设计模式</center>

## 1 设计模式基础

### 1. 设计模式的优点

   1. 可以提高程序员的思维能力、编程能力和设计能力
   2. 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期
   3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强

### 2. 设计模式分为哪几类

   1. 根据目的来分：

      创建型模式：以灵活的方式创建对象集合，用于管理对象的创建。包含：单例、原型、工厂方法、抽象工程、<font color="#e1e9ee">~~建造者~~</font>

      结构型模式：将已有的代码集成到新的面向对象中，用于处理类或对象的组合。包含：代理、外观、<font color="#e1e9ee">~~适配器、桥接、装饰、享元、组合~~</font>

      行为型模式：用于描述对类或对象怎样交互和怎样分配职责。包含：模板方法、策略、<font color="#e1e9ee">~~命令、职责脸、状态、观察者、中介者、迭代去、访问者、备忘录、解释器~~、</font>

   2. 根据作用范围来分：

      类模式：工厂方法、模板方法、<font color="#e1e9ee">~~适配器、解释器~~</font>

      对象模式：（除了以上四种都是）

### 3. 类之间的关系

   1. 耦合度从弱到强：

      依赖关系（- - - >）：耦合度最低的一种关联方式，是临时性的关联

      关联关系（—）：是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的关系

      聚合关系（—◇）：强关联关系，是整体和部分之间的关系

      组合关系（—◆）：关联关系的一种，是整体与部分之间更强烈的聚合的关系

      泛化关系（—▷）：耦合度最大的的一种关系，表示父类和子类之间的继承关系

      实现关系（- - - ▷）：是接口和实现类之间的关系，类中要实现接口中的所有抽象方法

### 4. 单选题：

   1. 以下对开闭原则的描述错误的是（A）

      - [x] A. 开闭原则与“对可变性的封装原则”没有相似性

      - [ ] B. 找到一个系统的可变元素，将他封装起来，叫开闭原则

      - [ ] C. 对修改关闭，是其原则之一

      - [ ] D. 从抽象层导出一个或多个新的类可以改变系统的行为，是其原则之一

### 5. 多选题

   1. 以下是模式的基本要素（ABCD）

      - [x] 名称

      - [x] 意图

      - [x] 解决方案

      - [x] 参与者和协作者

        

   2. 面向对象系统中功能复用的最常用技术（AB）

      - [x] 类继承

      - [x] 对象组合

      - [ ] 使用抽象类

      - [ ] 使用实现类

### 6. 设计模式的两大主题：

   系统复用、系统扩展

### 7. 七大原则

   1. 开闭原则：

      软件实体应当对扩展开放，对修改关闭。（对软件测试的影响、可以提高代码的可复用性、可以提高软件的可维护性

   2. 里氏替换原则：

      继承必须确保父类拥有的性质在子类中仍然成立

   3. 依赖倒置原则：

      高层模块不应该依赖底层模块，两者都应该依赖其抽象

   4. 单一职责原则：

      一个类应该有且仅有一个引起它变化的原因

   5. 接口隔离原则：

      一个类对另一个类的依赖应该建立在最小的接口上

   6. 迪米特法则：

      又叫最少知识原则，如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用

   7. 合成复用原则：

      又叫组合/聚合原则，尽量使用合成或聚合等关系来实现，其次才考虑继承关系实现

## 2 创建型模式

### 1. 单例模式

   1. 定义：

      **一个类只能有一个实例**，且该类能自行创建这个实例的一种模式。（ Windows 的任务管理器只能打开一个，避免内存浪费）

   2. 主要角色：

      1. 单例类：包含一个实例且能够自行创建这个实例的类
      2. 访问类：使用单例的类

   3. 两种实现形式：

      懒汉式单例、饿汉式单例

   4. 应用场景：

      1. 某类只要求生成一个对象的时候，如总统、班长、太阳等
      2. 当对象需要被共享的场合，由于单例模式只允许创建一个对象，共享该对象可以节省资源
      3. 某一个类需要频繁实例化，对象又频繁被销毁的时候

### 2. 工厂方法

   1. 主要角色：

      1. 抽象工厂
      2. 具体工厂
      3. 抽象产品
      4. 具体产品
      
   1. 工厂方法和简单工厂的区别

      简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。

### 3. 抽象工厂模式

   1. 主要角色：

      （与工厂方法一致）

   2. 产品族、产品等级

      产品族：将同一个具体工厂所产生的位于不同等级的一组产品称为一个产品族

      产品等级：同一种产品称为一个产品等级

   3. 工厂方法和抽象工厂方法区别

      工厂模式是用来创建同一个产品的不同类型的（不同品牌的空调），但是抽象工厂模式可以用来创建不同类的各个产品（不同品牌的空调、冰箱、洗衣机等产品）

### 4. 单选题：

   1. 以下关于创建型模式说法正确的是（A）

      - [x] 创建型模式关注的是对象的创建

      - [ ] 创建型模式关注的是功能的实现

      - [ ] 创建型模式关注的是组织类和对象常用方法

      - [ ] 创建型模式关注的是对象间的协作

        

   2. 在（C）适合使用单例模式

      - [ ] 当一个类不知道她所必须创建的对象的类的时候

      - [ ] 当一个类的实例只能有几个不同状态组合中的一种时

      - [x] 当这个唯一实力应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时

      - [ ] 当一个类希望有它的子类来指定它所创建的对象的时候

### 5. 多选题：

   1. 下面属于原型模式的优点是（ABCD）
      - [x] 运行时刻增加和删除产品
      
      - [x] 改变值以指定新对象
      
      - [x] 减少子类的构造
      
      - [x] 用类动态配置应用
      
        
      
   2. 以下属于单例模式的优点是（ABCD）
      - [x] 对唯一实例的受控访问
      
      - [x] 允许对操作和表示的精化
      
      - [x] 允许可变数目的实例
      
      - [x] 比类操作更灵活
      
        
      
   3. 当应用工厂方法模式时需要考虑（ABCD）
      - [x] 主要有两种不同的情况
      
      - [x] 参数化工厂方法

      - [x] 特定语言的变化和问题

      - [x] 使用模板以避免创建子类

## 3 结构型模式

### 1. 代理模式

   1. 主要角色：

      1. 抽象主题类
      2. 真实主题类
      3. 代理类

   1. 结构图：

      ![代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/代理模式-9de.jpg)

   1. （明星）例子：

      结构图：

      ![明星代理模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/图片1-f10.png)

      代码：

      ```java
      package porxy;
      
      public interface Star {
        void confer();                 //面谈
        void signContrack();           //签合同
        void bookTicket();             //订票
        void sing();                  //唱歌
        void collectmoney();            //收钱
      }
      
      public class RealStar implements Star{
      	 public void confer(){               //面谈
      	    System.out.println("RealStar.confer()");
      	 }
      	  public void signContrack(){           //签合同
      		  System.out.println("RealStar.signContrack()");  
      	  }
      	  public void bookTicket(){           //订票
      		  System.out.println("RealStar.bookTicket()");  
      	  }
      	  public void sing(){                  //唱歌
      		  System.out.println("RealStar(周杰伦本人).sing()");  
      	  }
      	  public void collectmoney(){            //收钱
      		  System.out.println("RealStar.collectmoney()");  
      	  }
      }
      
      public class porxyStar implements Star {
         private Star star;
         public porxyStar(Star star){
      	   super();
      	   this.star = star;
           }
         public void confer() {
      	  System.out.println("porxyStar.confer()");		
      	}
         public void signContrack() {
      		 System.out.println("porxyStar.signContrack()");	
      	}
      	public void bookTicket() {
      		System.out.println("porxyStar.bookTicket()");
      	}
      	public void sing() {
      		 star.sing();
      	}
      	public void collectmoney() {
      		 System.out.println("porxyStar.collectmoney()");
      	}
      }
      
      public class client {
      	public static void main(String[] args) {	
      	Star real = new RealStar();
      	Star porxy = new porxyStar(real);	
              porxy.confer();
              porxy.signContrack();
              porxy.bookTicket();
              porxy.sing();
              porxy.collectmoney();
      	}
      }
      ```

      

### 2. 外观模式

   1. 主要角色：

      1. 外观角色
      2. 子系统角色
      3. 客户角色

   1. 结构图：

      ![外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/C/Users/12748/Desktop/外观模式-61c.jpg)

   1. （注册公司）例子：

      结构图：

      ![注册公司外观模式](https://figurebed-1311634249.file.myqcloud.com/2022/E/typora/笔记/设计模式/外观模式2-015.png)

      代码：

      ```java
      package chapter05.facade;         //外观角色
      
      public class  Client{
      	public static void main(String[] args) {
      
      	new RegisterFacade().register();
      
      	}
      }
      
      public class RegisterFacade  {
          public void register(){
            工商总局 a = new 工商局();
            a.checkName();
      	    税务总局 b = new 税务局();
            b.texCertificate();
            质监总局 c = new 质监局();
            c.orgCodeCertificate();
            银行 d = new 工商银行()
            d.openAccount();
         }			
      }
      
      public interface 工商总局{
         void checkName();
      }
      class 工商局 implements 工商总局  {
      	System.out.println(“检查名字是否冲突！”);		
      }
      public interface 税务总局{
         void texCertificate();   //办理税务登记证
      }
      class 税务局 implements 税务总局  {
      	System.out.println(“在税务局办理税务登记证！”);		
      }
      public interface 银行{
         void openAccount();   //开户
      }
      class 工商银行 implements 银行  {
      	System.out.println(“在中国工商银行开户！”);			
      }
      public interface 质监总局{
         void orgCodeCertificate();   //办理组织结构代码证
      }
      class 质监局 implements 质监总局  {
      	System.out.println(“在质监总局办理组织结构代码证！”);		
      }
      ```

      

### 3. 单选题：

   1. 以下意图用来描述代理（Proxy）的是（C）
      - [ ] 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
      
      - [ ] 运用共享技术有效地支持大量细粒度的对象
      
      - [x] 为其他对象提供一种代理以控制对这个对象的访问
      
      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
      
        
      
   2. 以下情况不适合使用代理模式的是（A）
      - [x] 用户想使用一个已经存在的类，而它的接口不符合用户的需求
      
      - [ ] 根据需要创建开销很大的对象
      
      - [ ] 在需要用比较通用和复杂的对象指针代替简单的指针的时候
      
      - [ ] 取代了简单的指针，它在访问对象时执行一些附加操作
      
        
      
   3. 以下意图可以用来描述外观（A）
      - [x] 为子系统中的一组接口提供一个一致的界面，本模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
      
      - [ ] 定义一个用于创建对象发接口，让子类决定实例化哪一个类
      
      - [ ] 保证一个类仅有一个实例，并提供一个访问它的全局访问点
      
      - [ ] 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态

## 4 行为型模式

### 1. 模板方法

   1. 定义：

      定义一个操作中的算法框架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤

   2. 主要角色：

      1. 抽象类
      2. 具体子类

   3. 应用场景：

      1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
      2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。
      3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进
         行扩展。

### 2. 策略模式

   1. 定义：

      该模式定义了一系列算法，并将每个算法封装起来，用一个环境类调用。<font color="#e1e9ee">~~使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。~~</font>（从太原到西安旅游的出行方式：坐火车、坐汽车、自行车，所以该实例使用策略模式比价适合）

   2. 主要角色：

      1. 抽象策略类
      2. 具体策略类
      3. 环境类
   
   3. 应用场景：
   
      1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
      
      2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
      
      3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
      
      4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关
         的数据结构。
      
      5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

### 3. 单选题：

   1. 以下意图（D）可用来描述策略
      
      - [ ] 将抽象部分与它的实现部分分离，使它们都可以独立变化
      
      - [ ] 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
      
      - [ ] 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中
      
      - [x] 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换
      
   2. 以下（A）不适合使用策略模式
      
      - [x] 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，用户不希望这些对象是紧密耦合的
      
      - [ ] 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法
      
      - [ ] 需要使用一个算法的不同变体。例如，用户可能会定义一些反映不同的空间时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式
      
      - [ ] 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构
